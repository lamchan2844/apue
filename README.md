# apue
apue-example

## ch8

进程控制
- 创建新进程
- 执行程序
- 进程终止

### 进程标识

进程的id是唯一的，可以延迟复用

### fork
```
#include <unistd.h>
pid_t fork(void);
```
fork创建子进程，fork调用一次，返回两次，子进程返回0，父进程返回子进程id。
子进程获得父进程数据空间、堆和栈的**副本**，但是父进程和子进程并不共享这些存储空间部分，父进程和子进程共享正文段。

### vfork
1. 子进程在父进程的空间中运行，如果子进程修改数据、函数调用、或者没有掉用exec或者exit就返回可能带来未知结果。
2. vfork保证子进程先运行，在子进程调用exec或exit之后父进程才能被调度运行。


### exit
##### 进程有下面5种正常终止方式：

1. 在main函数内执行return语句。这等效于调用exit。

2. 调用exit函数。此函数有ISO C定义，其操作包括调用各终止处理程序（终止处理程序在调用atexit函数时登记），然后关闭所有标准I/O流等。

3.调用_exit或_Exit函数。ISO C定义_Exit，其目的是为进程提供一种无需运行终止处理程序或信号处理程序而终止的方法。对标准I/O流是否进行冲洗，这取决于实现。在UNIX系统中。函数_Exit和_exit是同义的，并不清洗标准I/O流。函数_exit由exit调用，它处理UNIX特定的细节。在大多数UNIX系统实现中，exit（3）是标准C库中的一个函数，而_exit（2）则是一个系统调用。

4. 进程的最后一个线程在其启动例程中执行返回语句。但是，该线程的返回值不会用作进程的返回值。当最后一个线程从其启动例程返回时，该进程以终止状态0返回。

5. 进程的最后一个线程调用pthread_exit函数。在这种情况下，进程终止状态总是0，这与传送给pthread_exit的参数无关。

##### 三种异常终止方式如下：

1. 调用abort。它产生SIGABRT信号，这是下一种异常终止的特例。

2. 当进程接收到某些信号时。信号可由进程自身（例如调用abort函数）、其他进程或内核产生。

3. 最后一个线程对“取消”（cancellation）请求作出响应。按系统默认，“取消”以延迟方式发生：一个线程要求取消另一个线程，一段时间之后，目标线程终止。

**不管进程如何终止，最后都会执行内核中的同一段代码。这段代码为相应进程关闭所有打开描述符，释放它所使用的存储器等。**

该终止进程的父进程都能用wait或waitpid函数取得其终止状态。

子进程是在父进程fork之后生成的，子进程终止后将其终止状态返回给父进程，若父进程在子进程之前终止，则子进程的父进程都改变为init进程，保证了每个进程都有父进程

子进程在父进程前终止，那么父进程如何能在做响应检查时得到子进程的终止状态呢？内核为每个终止的进程保存一定的信息，当终止进程的父进程调用wait或者waitpid时，可以得到这些信息。

僵死进程：进程已经终止，但是其父进程尚未对其进行善后处理（获取终止进程的有关信息、释放它仍占用的资源），称之为僵死进程（zombie）

init被编写为无论何时其子进程终止，init就调用wait来取得其终止状态，避免了僵死进程，值得注意的是，init的子进程即可能指init自己产生的进程，也可能是其收养的进程。

### wait和waitpid
当进程终止后，会向父进程发送SIGCHLD信号，父进程可以选择忽略或者提供一个执行函数。系统默认动作是忽略。

当调用wait或者waitpid时，会发生三种情况：
1. 如果其所有子进程都在运行，阻塞
2. 如果一个子进程终止，取得该进程的终止状态并立即返回
3. 没有子进程，立即出错返回。

```
#include <sys/wait.h>
pid_t wait(int *statloc);
pid_t waitpid(pid_t pid, int *statloc, int options);
```
**wait和waitpid的区别**
1. 在一个子进程终止之前，wait使其调用者阻塞，waitpid有一选项，可使调用者不阻塞。
2. waitpid并不等待其调用之后的第一个终止的子进程，有若干选型，可以控制等待的子进程。
